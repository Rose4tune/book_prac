<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>hi</h1>
  <script type="module" src="./fx.js"></script>
  <script type="module">
    import * as fx from './fx.js';
    const log = console.log;

    fx.go(
      Promise.resolve(1),
      a => a + 10,
      a => Promise.resolve(a + 100),
      a => a + 1000,
      a => a + 10000,
      // log
    );
    
    fx.go(
      Promise.resolve(2),
      a => a + 20,
      a => Promise.reject('error~~'),
      a => console.log('----'),
      a => a + 2000,
      a => a + 20000,
      // log
    )
    .catch(
      a => console.log(a)
    );



    /**
     * Promise.then의 중요한 규칙
     *  - Promise 체인이 연속적으로 대기가 걸려있어도, 한번의 then으로 원하는 결과를 받을 수 있다.
     */

    Promise.resolve(Promise.resolve(Promise.resolve(1))).then(function(a){
      log(a) // Promise가 아무리 깊어도 제일 안쪽의 값을 가져옴
    });

    new Promise(resolve => resolve(new Promise(resolve => resolve(3)))).then(log)








    // 장난치기..ㅋㅋㅋ
    // const crues = ['이도윤', '이예서', '최정인', '이나영'];

    // let randArr = [];
    // crues.forEach(person => {
    //   let rand = Math.floor(Math.random()*person.length);
    //   if(!randArr.includes(rand)){
    //     randArr.push(person[rand]);
    //   } else {
    //     randArr.push(person[rand+1]);
    //   }
    // });

    // fx.go(
    //   randArr,
    //   fx.reduce(fx.add),
    //   log
    // )

  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <h1>비동기적으로 기존 함수들을 변경해보자!!</h1>
  <script type="module" src="./fx.js"></script>



  <h2>1. go / reduce</h2>
  <script type="module">
    import * as fx from './fx.js';
    var log = console.log;

    fx.go(
      Promise.resolve(1),
      a => a + 10,
      a => Promise.resolve(a + 100),
      a => a + 1000,
      a => a + 10000,
      // log
    );

    fx.go(
      Promise.resolve(2),
      a => a + 20,
      a => Promise.reject('error~~'),
      a => console.log('----'),
      a => a + 2000,
      a => a + 20000,
      // log
    ).catch(
      a => console.log(a)
    );

    // Promise.then의 중요한 규칙
    //  - Promise 체인이 연속적으로 대기가 걸려있어도, 한번의 then으로 원하는 결과를 받을 수 있다.
    Promise.resolve(Promise.resolve(Promise.resolve(1))).then(function (a) {
      log(a) // Promise가 아무리 깊어도 제일 안쪽의 값을 가져옴
    });
    new Promise(resolve => resolve(new Promise(resolve => resolve(3)))).then(log)
  </script>






  <h2>2. L.map / map / take</h2>
  <script type="module">
    import * as fx from './fx.js';
    var log = console.log;
    console.clear();

    fx.go(
      // [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
      // fx.range(3),
      [1, 2, 3, 67],
      fx.L.map(a => Promise.resolve(a + 10)),
      fx.take(2),
      log
    )

    fx.go(
      // [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
      // fx.range(3),
      [1, 2, 3, 67],
      // fx.L.map(a => a + 10),
      // fx.takeAll,
      fx.map(a => Promise.resolve(a + 10)),
      log
    )
  </script>




  <h2>3. L.filter / filter / nop / take</h2>
  <script type="module">
    import * as fx from './fx.js';
    var log = console.log;
    console.clear();

    // Kleisli Composition
    fx.go(
      // [1, 2, 3, 4, 5, 6],
      fx.range(10),
      fx.L.map(a => Promise.resolve(a * a)),
      // fx.L.filter(a => a % 2),
      fx.L.filter(a => Promise.resolve(a % 2)),
      fx.take(5),
      log
    )

    // reduce에서 nop 지원
  </script>
  

</body>

</html>